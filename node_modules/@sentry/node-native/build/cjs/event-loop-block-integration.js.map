{"version":3,"file":"event-loop-block-integration.js","sources":["../../src/event-loop-block-integration.ts"],"sourcesContent":["import { isPromise } from 'node:util/types';\nimport { isMainThread, Worker } from 'node:worker_threads';\nimport type {\n  Client,\n  ClientOptions,\n  Contexts,\n  DsnComponents,\n  Event,\n  EventHint,\n  Integration,\n  IntegrationFn,\n} from '@sentry/core';\nimport { debug, defineIntegration, getClient, getFilenameToDebugIdMap, getIsolationScope } from '@sentry/core';\nimport type { NodeClient } from '@sentry/node';\nimport { registerThread, threadPoll } from '@sentry-internal/node-native-stacktrace';\nimport type { ThreadBlockedIntegrationOptions, WorkerStartData } from './common';\nimport { POLL_RATIO } from './common';\n\nconst INTEGRATION_NAME = 'ThreadBlocked';\nconst DEFAULT_THRESHOLD_MS = 1_000;\n\nfunction log(message: string, ...args: unknown[]): void {\n  debug.log(`[Sentry Event Loop Blocked] ${message}`, ...args);\n}\n\n/**\n * Gets contexts by calling all event processors. This shouldn't be called until all integrations are setup\n */\nasync function getContexts(client: NodeClient): Promise<Contexts> {\n  let event: Event | null = { message: INTEGRATION_NAME };\n  const eventHint: EventHint = {};\n\n  for (const processor of client.getEventProcessors()) {\n    if (event === null) break;\n    event = await processor(event, eventHint);\n  }\n\n  return event?.contexts || {};\n}\n\ntype IntegrationInternal = { start: () => void; stop: () => void };\n\nfunction poll(enabled: boolean, clientOptions: ClientOptions): void {\n  try {\n    const currentSession = getIsolationScope().getSession();\n    // We need to copy the session object and remove the toJSON method so it can be sent to the worker\n    // serialized without making it a SerializedSession\n    const session = currentSession ? { ...currentSession, toJSON: undefined } : undefined;\n    // message the worker to tell it the main event loop is still running\n    threadPoll({ session, debugImages: getFilenameToDebugIdMap(clientOptions.stackParser) }, !enabled);\n  } catch {\n    // we ignore all errors\n  }\n}\n\n/**\n * Starts polling\n */\nfunction startPolling(\n  client: Client,\n  integrationOptions: Partial<ThreadBlockedIntegrationOptions>,\n): IntegrationInternal | undefined {\n  registerThread();\n\n  let enabled = true;\n\n  const initOptions = client.getOptions();\n  const pollInterval = (integrationOptions.threshold || DEFAULT_THRESHOLD_MS) / POLL_RATIO;\n\n  // unref so timer does not block exit\n  setInterval(() => poll(enabled, initOptions), pollInterval).unref();\n\n  return {\n    start: () => {\n      enabled = true;\n    },\n    stop: () => {\n      enabled = false;\n      // poll immediately because the timer above might not get a chance to run\n      // before the event loop gets blocked\n      poll(enabled, initOptions);\n    },\n  };\n}\n\n/**\n * Starts the worker thread that will monitor the other threads.\n *\n * This function is only called in the main thread.\n */\nasync function startWorker(\n  dsn: DsnComponents,\n  client: NodeClient,\n  integrationOptions: Partial<ThreadBlockedIntegrationOptions>,\n): Promise<void> {\n  const contexts = await getContexts(client);\n\n  // These will not be accurate if sent later from the worker thread\n  delete contexts.app?.app_memory;\n  delete contexts.device?.free_memory;\n\n  const initOptions = client.getOptions();\n\n  const sdkMetadata = client.getSdkMetadata() || {};\n  if (sdkMetadata.sdk) {\n    sdkMetadata.sdk.integrations = initOptions.integrations.map(i => i.name);\n  }\n\n  const options: WorkerStartData = {\n    debug: debug.isEnabled(),\n    dsn,\n    tunnel: initOptions.tunnel,\n    environment: initOptions.environment || 'production',\n    release: initOptions.release,\n    dist: initOptions.dist,\n    sdkMetadata,\n    appRootPath: integrationOptions.appRootPath,\n    threshold: integrationOptions.threshold || DEFAULT_THRESHOLD_MS,\n    maxEventsPerHour: integrationOptions.maxEventsPerHour || 1,\n    staticTags: integrationOptions.staticTags || {},\n    contexts,\n  };\n\n  const worker = new Worker(new URL('./event-loop-block-watchdog.js', import.meta.url), {\n    workerData: options,\n    // We don't want any Node args like --import to be passed to the worker\n    execArgv: [],\n    env: { ...process.env, NODE_OPTIONS: undefined },\n  });\n\n  process.on('exit', () => {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    worker.terminate();\n  });\n\n  worker.once('error', (err: Error) => {\n    log('watchdog worker error', err);\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    worker.terminate();\n  });\n\n  worker.once('exit', (code: number) => {\n    log('watchdog worker exit', code);\n  });\n\n  // Ensure this thread can't block app exit\n  worker.unref();\n}\n\nconst _eventLoopBlockIntegration = ((options: Partial<ThreadBlockedIntegrationOptions> = {}) => {\n  let polling: IntegrationInternal | undefined;\n\n  return {\n    name: INTEGRATION_NAME,\n    async afterAllSetup(client: NodeClient): Promise<void> {\n      const dsn = client.getDsn();\n\n      if (!dsn) {\n        log('No DSN configured, skipping starting integration');\n        return;\n      }\n\n      try {\n        polling = await startPolling(client, options);\n\n        if (isMainThread) {\n          await startWorker(dsn, client, options);\n        }\n      } catch (err) {\n        log('Failed to start integration', err);\n      }\n    },\n    start() {\n      polling?.start();\n    },\n    stop() {\n      polling?.stop();\n    },\n  } as Integration & IntegrationInternal;\n}) satisfies IntegrationFn;\n\n/**\n * Monitors the Node.js event loop for blocking behavior and reports blocked events to Sentry.\n *\n * Uses a background worker thread to detect when the main thread is blocked for longer than\n * the configured threshold (default: 1 second).\n *\n * When instrumenting via the `--import` flag, this integration will\n * automatically monitor all worker threads as well.\n *\n * ```js\n * // instrument.mjs\n * import * as Sentry from '@sentry/node';\n * import { eventLoopBlockIntegration } from '@sentry/node-native';\n *\n * Sentry.init({\n *   dsn: '__YOUR_DSN__',\n *   integrations: [\n *     eventLoopBlockIntegration({\n *       threshold: 500, // Report blocks longer than 500ms\n *     }),\n *   ],\n * });\n * ```\n *\n * Start your application with:\n * ```bash\n * node --import instrument.mjs app.mjs\n * ```\n */\nexport const eventLoopBlockIntegration = defineIntegration(_eventLoopBlockIntegration);\n\nexport function disableBlockDetectionForCallback<T>(callback: () => T): T;\nexport function disableBlockDetectionForCallback<T>(callback: () => Promise<T>): Promise<T>;\n/**\n * Disables Event Loop Block detection for the current thread for the duration\n * of the callback.\n *\n * This utility function allows you to disable block detection during operations that\n * are expected to block the event loop, such as intensive computational tasks or\n * synchronous I/O operations.\n */\nexport function disableBlockDetectionForCallback<T>(callback: () => T | Promise<T>): T | Promise<T> {\n  const integration = getClient()?.getIntegrationByName(INTEGRATION_NAME) as IntegrationInternal | undefined;\n\n  if (!integration) {\n    return callback();\n  }\n\n  integration.stop();\n\n  try {\n    const result = callback();\n    if (isPromise(result)) {\n      return result.finally(() => integration.start());\n    }\n\n    integration.start();\n    return result;\n  } catch (error) {\n    integration.start();\n    throw error;\n  }\n}\n\n/**\n * Pauses the block detection integration.\n *\n * This function pauses event loop block detection for the current thread.\n */\nexport function pauseEventLoopBlockDetection(): void {\n  const integration = getClient()?.getIntegrationByName(INTEGRATION_NAME) as IntegrationInternal | undefined;\n\n  if (!integration) {\n    return;\n  }\n\n  integration.stop();\n}\n\n/**\n * Restarts the block detection integration.\n *\n * This function restarts event loop block detection for the current thread.\n */\nexport function restartEventLoopBlockDetection(): void {\n  const integration = getClient()?.getIntegrationByName(INTEGRATION_NAME) as IntegrationInternal | undefined;\n\n  if (!integration) {\n    return;\n  }\n\n  integration.start();\n}\n"],"names":["debug","getIsolationScope","threadPoll","getFilenameToDebugIdMap","registerThread","POLL_RATIO","Worker","isMainThread","defineIntegration","getClient","isPromise"],"mappings":"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"}